<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Elevator Conversation Cards</title>
  <style>
    :root { --pad: 16px; --radius: 14px; }
    body {
      margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: #f7f7f8; color: #111;
    }
    header {
      padding: 18px var(--pad) 10px; background: white; position: sticky; top: 0; z-index: 10;
      border-bottom: 1px solid rgba(0,0,0,.08);
    }
    h1 { margin: 0 0 6px; font-size: 18px; }
    .sub { margin: 0; font-size: 13px; color: #444; }
    main { padding: var(--pad); max-width: 900px; margin: 0 auto; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }

    button {
      font-size: 15px; padding: 10px 12px; border-radius: 12px;
      border: 1px solid rgba(0,0,0,.15); background: white;
      cursor: pointer;
    }
    button.primary { background: #111; color: white; }
    button.warn { background: #fff4f4; }
    button:disabled { opacity: .5; cursor: not-allowed; }

    .meta {
      margin-top: 10px; font-size: 12px; color: #555;
      display: flex; justify-content: space-between; gap: 10px; flex-wrap: wrap;
    }
    .cards {
      margin-top: 14px; display: grid; gap: 12px;
      grid-template-columns: 1fr;
    }
    .card {
      background: white; border: 1px solid rgba(0,0,0,.10); border-radius: var(--radius);
      padding: 14px; box-shadow: 0 1px 2px rgba(0,0,0,.04);
    }
    .card.locked {
      opacity: 0.45;
    }
    .tagRow {
      display:flex; justify-content: space-between; align-items: center; gap:10px; flex-wrap:wrap;
      margin-bottom: 10px;
    }
    .tag {
      display: inline-block; font-size: 12px; padding: 3px 8px; border-radius: 999px;
      background: rgba(0,0,0,.06); color: #222;
    }
    .text { font-size: 20px; line-height: 1.25; margin: 0; }
    .small { font-size: 12px; color: #666; margin: 10px 0 0; }
    .btnRow { display:flex; gap:10px; flex-wrap:wrap; margin-top: 12px; }
    .btnSmall {
      font-size: 14px; padding: 10px 12px; border-radius: 12px;
      border: 1px solid rgba(0,0,0,.15); background: white;
    }
    .btnComplete { background:#111; color:#fff; }
    .btnRedraw { background:#f1f1f2; }

    .footer {
      margin: 18px 0 0; font-size: 12px; color: #666;
      padding-bottom: 40px;
    }
    .kbd {
      font-size: 12px; padding: 2px 6px; border-radius: 8px;
      background: rgba(0,0,0,.06);
    }
    .muted { color:#666; font-size: 13px; }

    /* Modal */
    .modalBackdrop {
      position: fixed; inset: 0; background: rgba(0,0,0,.45);
      display: none; align-items: center; justify-content: center;
      padding: 18px; z-index: 999;
    }
    .modal {
      width: min(820px, 100%);
      background: white; border-radius: 16px;
      border: 1px solid rgba(0,0,0,.15);
      box-shadow: 0 10px 30px rgba(0,0,0,.2);
      overflow: hidden;
    }
    .modalHeader {
      padding: 14px 16px;
      display: flex; align-items: center; justify-content: space-between; gap: 10px;
      border-bottom: 1px solid rgba(0,0,0,.08);
    }
    .modalHeader h2 { margin: 0; font-size: 16px; }
    .modalBody { padding: 14px 16px; max-height: 70vh; overflow:auto; }
    .modalFooter {
      padding: 12px 16px; border-top: 1px solid rgba(0,0,0,.08);
      display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end;
    }
    .sectionTitle {
      margin: 14px 0 8px;
      font-size: 13px;
      color: #333;
      font-weight: 650;
    }
    .deckList { margin: 0; padding-left: 18px; }
    .deckList li { margin: 6px 0; line-height: 1.25; }

    /* Log formatting */
    .completedItem { margin: 8px 0; line-height: 1.25; }
    .completedReflection { font-weight: 700; }
  </style>
</head>
<body>
  <header>
    <h1>Elevator Conversation Cards</h1>
    <p class="sub">Start a round, use prompts naturally, then end with one reflection.</p>
  </header>

  <main>
    <div class="row">
      <button class="primary" id="start">Start Round (Deal 3)</button>
      <button id="endRound" disabled>End Conversation</button>
      <button id="viewCompleted">Review Log</button>
      <button id="viewDeck">View Full Deck</button>
      <button class="warn" id="reset">Reset Game</button>
    </div>

    <div class="meta">
      <div>Remaining in deck: <strong id="remaining">—</strong></div>
      <div>Completed: <strong id="score">0</strong></div>
      <div>Round: <strong id="round">0</strong></div>
    </div>

    <section class="cards" id="cards"></section>

    <div class="footer">
      <div><strong>Tip:</strong> If a prompt feels awkward, tap <span class="kbd">Redraw</span> on that card to swap it out. (The old one goes back into the deck.)</div>
      <div style="margin-top:8px;">Used prompts stay out of rotation until you reset the game.</div>
    </div>
  </main>

  <!-- Review Log modal -->
  <div class="modalBackdrop" id="backdropLog" role="dialog" aria-modal="true" aria-labelledby="logTitle">
    <div class="modal">
      <div class="modalHeader">
        <h2 id="logTitle">Review Log</h2>
        <button class="btnSmall" id="closeLog" aria-label="Close">Close</button>
      </div>
      <div class="modalBody">
        <div id="logEmpty" class="muted" style="display:none;">Nothing logged yet. Start a round and complete a prompt.</div>
        <ol id="logList"></ol>
      </div>
      <div class="modalFooter">
        <button class="btnSmall" id="copyLog">Copy log</button>
        <button class="btnSmall warn" id="clearLog">Clear log + score</button>
      </div>
    </div>
  </div>

  <!-- Full deck modal -->
  <div class="modalBackdrop" id="backdropDeck" role="dialog" aria-modal="true" aria-labelledby="deckTitle">
    <div class="modal">
      <div class="modalHeader">
        <h2 id="deckTitle">Full Deck</h2>
        <button class="btnSmall" id="closeDeck" aria-label="Close">Close</button>
      </div>
      <div class="modalBody">
        <div class="muted">All categories and prompts (read-only).</div>
        <div id="deckContainer"></div>
      </div>
      <div class="modalFooter">
        <button class="btnSmall" id="copyDeck">Copy full deck</button>
      </div>
    </div>
  </div>

  <!-- Reflection modal -->
  <div class="modalBackdrop" id="backdropReflection" role="dialog" aria-modal="true" aria-labelledby="reflectionTitle">
    <div class="modal">
      <div class="modalHeader">
        <h2 id="reflectionTitle">Reflections and Takeaways</h2>
        <button class="btnSmall" id="closeReflection" aria-label="Close">Close</button>
      </div>
      <div class="modalBody">
        <div class="muted">Answer this out loud as a group before you rotate.</div>
        <div class="card" style="margin-top:12px;">
          <div class="tagRow">
            <span class="tag" id="reflectionTag">Round —</span>
          </div>
          <p class="text" id="reflectionText">—</p>
          <p class="small">When you are done, close this window. You will be prompted to start the next round.</p>
        </div>
      </div>
      <div class="modalFooter">
        <button class="btnSmall" id="copyReflection">Copy reflection</button>
      </div>
    </div>
  </div>

  <script>
    // --- Main deck (action prompts) ---
    const DECK = [
      // I. Entry & Opening Moves
      {cat:"Entry & Opening", text:"Begin with a curiosity, not a claim."},
      {cat:"Entry & Opening", text:"Start with something you’ve been noticing lately."},
      {cat:"Entry & Opening", text:"Open with a “because,” even if the sentence is unfinished."},
      {cat:"Entry & Opening", text:"Say one sentence that would never appear on LinkedIn."},
      {cat:"Entry & Opening", text:"Begin with uncertainty rather than confidence."},
      {cat:"Entry & Opening", text:"Start mid-thought."},
      {cat:"Entry & Opening", text:"Open by naming a tension you’re sitting with."},
      {cat:"Entry & Opening", text:"Begin with what surprised you recently."},
      {cat:"Entry & Opening", text:"Start by referencing something outside yourself."},
      {cat:"Entry & Opening", text:"Begin with a question instead of a statement."},

      // II. Listening & Response Moves
      {cat:"Listening & Response", text:"Echo one phrase someone else used before responding."},
      {cat:"Listening & Response", text:"Ask a follow-up that makes the previous answer sharper."},
      {cat:"Listening & Response", text:"Paraphrase what you just heard, then add one word."},
      {cat:"Listening & Response", text:"Respond to why, not what."},
      {cat:"Listening & Response", text:"Notice what didn’t get said and ask about it."},
      {cat:"Listening & Response", text:"Build directly on someone else’s idea."},
      {cat:"Listening & Response", text:"Ask a clarifying question before offering your view."},
      {cat:"Listening & Response", text:"Respond with curiosity, not evaluation."},
      {cat:"Listening & Response", text:"Let someone else finish a thought you could complete."},
      {cat:"Listening & Response", text:"Pause for two seconds before speaking."},

      // III. Persona & Stance
      {cat:"Persona & Stance", text:"Name a value you actually practice."},
      {cat:"Persona & Stance", text:"Say what kind of collaborator you try not to be."},
      {cat:"Persona & Stance", text:"Describe a habit that shapes how you work with others."},
      {cat:"Persona & Stance", text:"Say what you tend to notice before others do."},
      {cat:"Persona & Stance", text:"Name something you care about more than efficiency."},
      {cat:"Persona & Stance", text:"Say what drains your energy in group work."},
      {cat:"Persona & Stance", text:"Say what reliably gives you energy."},
      {cat:"Persona & Stance", text:"Describe how you behave when things get stuck."},
      {cat:"Persona & Stance", text:"Name a role you often end up playing on teams."},
      {cat:"Persona & Stance", text:"Say how you know when a project is going well."},

      // IV. Value & “So What”
      {cat:"Value & So What", text:"Explain how your work makes something easier for others."},
      {cat:"Value & So What", text:"Name a result you care about beyond success or failure."},
      {cat:"Value & So What", text:"Say what improves when you’re in the room."},
      {cat:"Value & So What", text:"Translate what you do into a benefit someone else might feel."},
      {cat:"Value & So What", text:"Say what problem you quietly like solving."},
      {cat:"Value & So What", text:"Name an outcome you’re trying to make more likely."},
      {cat:"Value & So What", text:"Say what kind of impact actually matters to you."},
      {cat:"Value & So What", text:"Describe value without using adjectives."},
      {cat:"Value & So What", text:"Say who tends to benefit most from your strengths."},
      {cat:"Value & So What", text:"Name a consequence you’ve learned to watch for."},

      // V. “Why” & Motivation
      {cat:"Why & Motivation", text:"Use the word “because” once."},
      {cat:"Why & Motivation", text:"Say what originally pulled you toward this interest."},
      {cat:"Why & Motivation", text:"Name a frustration that motivates you."},
      {cat:"Why & Motivation", text:"Say what you’d work on even if no one rewarded it."},
      {cat:"Why & Motivation", text:"Describe what keeps your attention over time."},
      {cat:"Why & Motivation", text:"Say what made this feel worth pursuing."},
      {cat:"Why & Motivation", text:"Name a belief that shapes your decisions."},
      {cat:"Why & Motivation", text:"Say what you’d miss if you couldn’t do this anymore."},
      {cat:"Why & Motivation", text:"Describe a moment that clarified something for you."},
      {cat:"Why & Motivation", text:"Say why this matters now, not eventually."},

      // VI. Direction & Future
      {cat:"Direction & Future", text:"Say what you’re trying to get better at right now."},
      {cat:"Direction & Future", text:"Name something you’re actively testing."},
      {cat:"Direction & Future", text:"Say what you’re curious about becoming."},
      {cat:"Direction & Future", text:"Describe a direction without naming a destination."},
      {cat:"Direction & Future", text:"Say what you hope changes over the next year."},
      {cat:"Direction & Future", text:"Name a skill you’re intentionally developing."},
      {cat:"Direction & Future", text:"Say what you’re willing to revise about your plans."},
      {cat:"Direction & Future", text:"Describe a risk you’re open to taking."},
      {cat:"Direction & Future", text:"Say what you’re exploring rather than committing to."},
      {cat:"Direction & Future", text:"Name what you’re learning to let go of."},

      // VII. Connection & Invitation
      {cat:"Connection & Invitation", text:"Ask a question you genuinely want answered."},
      {cat:"Connection & Invitation", text:"Invite a second conversation without asking for anything."},
      {cat:"Connection & Invitation", text:"Name a possible overlap between you and someone else."},
      {cat:"Connection & Invitation", text:"Say how someone else’s interest connects to yours."},
      {cat:"Connection & Invitation", text:"Ask who else should be in this conversation."},
      {cat:"Connection & Invitation", text:"Invite collaboration without defining it yet."},
      {cat:"Connection & Invitation", text:"Ask what kind of help would actually be useful."},
      {cat:"Connection & Invitation", text:"Say what kind of conversation you’d like to continue."},
      {cat:"Connection & Invitation", text:"Invite comparison rather than agreement."},
      {cat:"Connection & Invitation", text:"End your turn with an opening, not a summary."},

      // VIII. Constraint & Craft
      {cat:"Constraint & Craft", text:"Avoid naming your major or job."},
      {cat:"Constraint & Craft", text:"Use only one adjective this round."},
      {cat:"Constraint & Craft", text:"Speak in sentence fragments."},
      {cat:"Constraint & Craft", text:"Ask a question before making a claim."},
      {cat:"Constraint & Craft", text:"Say less than you want to."},
      {cat:"Constraint & Craft", text:"Stop mid-thought and let it hang."},
      {cat:"Constraint & Craft", text:"Use a concrete example instead of abstraction."},
      {cat:"Constraint & Craft", text:"Explain without using industry jargon."},
      {cat:"Constraint & Craft", text:"Say it again, but simpler."},
      {cat:"Constraint & Craft", text:"Change your pacing halfway through."},

      // IX. Playful / Light Disruption
      {cat:"Playful Disruption", text:"Begin with “This might sound strange, but…”"},
      {cat:"Playful Disruption", text:"Use a metaphor you wouldn’t normally choose."},
      {cat:"Playful Disruption", text:"Say one thing you’d normally edit out."},
      {cat:"Playful Disruption", text:"Acknowledge the awkwardness, then continue."},
      {cat:"Playful Disruption", text:"Begin with “Quick version…”"},
      {cat:"Playful Disruption", text:"Pretend you’re already late for something."},
      {cat:"Playful Disruption", text:"End a sentence with “Anyway.”"},
      {cat:"Playful Disruption", text:"Say one thing you don’t have figured out."},
      {cat:"Playful Disruption", text:"Smile before you speak, then ignore it."},
      {cat:"Playful Disruption", text:"Deliver one line as if you’re confiding a secret."},
    ];

    // --- Reflection deck (end-cap) ---
    const REFLECTION_CATEGORY = "Reflections and Takeaways";
    const REFLECTION_DECK = [
      {cat: REFLECTION_CATEGORY, text:"What should we carry into the next conversation?"},
      {cat: REFLECTION_CATEGORY, text:"What did you learn about how you come across in a first meeting?"},
      {cat: REFLECTION_CATEGORY, text:"What question do you want to try asking in the next round?"},
      {cat: REFLECTION_CATEGORY, text:"What made this conversation easier than expected?"},
      {cat: REFLECTION_CATEGORY, text:"What made this conversation harder than expected?"},
      {cat: REFLECTION_CATEGORY, text:"Name one moment you felt genuinely engaged. What caused it?"},
      {cat: REFLECTION_CATEGORY, text:"What overlap did you notice that you did not expect?"},
      {cat: REFLECTION_CATEGORY, text:"What is one phrase you heard that you want to borrow (ethically)?"},
      {cat: REFLECTION_CATEGORY, text:"What is one small adjustment you will make in the next round?"},
      {cat: REFLECTION_CATEGORY, text:"What is one useful next step you could take after class, even if it is tiny?"},
      {cat: REFLECTION_CATEGORY, text:"What is one thing someone did that made it easier to talk?"},
      {cat: REFLECTION_CATEGORY, text:"What did you do well in this round that you should repeat?"}
    ];

    // ---- Helpers ----
    function shuffle(array){
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    // ---- State ----
    // Used main cards remain out of rotation until reset. We do NOT recycle used.
    const LS_KEY = "ecc_game_v5";
    const DEFAULT_STATE = {
      remaining: [],
      used: [],
      score: 0,
      active: [],
      completed: [],
      round: 0,
      reflectionDone: true,
      lockedBetweenRounds: false,     // NEW: freeze hand until next round begins
      reflectionRemaining: [],
      reflectionUsed: []
    };

    function loadState(){
      try {
        const raw = localStorage.getItem(LS_KEY);
        if (!raw) return null;
        const st = JSON.parse(raw);
        if (!st || !Array.isArray(st.completed)) return null;
        return st;
      } catch { return null; }
    }
    function saveState(st){
      localStorage.setItem(LS_KEY, JSON.stringify(st));
    }

    function buildMainDeck(){
      return shuffle(DECK.map((_, idx) => idx));
    }
    function buildReflectionDeck(){
      return shuffle(REFLECTION_DECK.map((_, idx) => idx));
    }

    function ensureDecks(st){
      if (!Array.isArray(st.remaining)) st.remaining = [];
      if (!Array.isArray(st.used)) st.used = [];
      if (!Array.isArray(st.active)) st.active = [];
      if (!Array.isArray(st.completed)) st.completed = [];

      if (!Array.isArray(st.reflectionRemaining) || st.reflectionRemaining.length === 0) {
        const recycled = Array.isArray(st.reflectionUsed) ? st.reflectionUsed.slice() : [];
        st.reflectionUsed = [];
        st.reflectionRemaining = shuffle(recycled.length ? recycled : buildReflectionDeck());
      }
      if (!Array.isArray(st.reflectionUsed)) st.reflectionUsed = [];

      return st;
    }

    function drawMainIndex(st){
      if (!Array.isArray(st.remaining) || st.remaining.length === 0) return null;
      const idx = st.remaining.pop();
      st.used.push(idx);
      return idx;
    }

    function returnMainToDeck(st, idx){
      if (typeof idx !== "number") return;
      st.used = (st.used || []).filter(x => x !== idx);
      st.remaining = st.remaining || [];
      st.remaining.push(idx);

      const n = st.remaining.length;
      const start = Math.max(0, n - 12);
      for (let i = n - 1; i > start; i--) {
        const j = start + Math.floor(Math.random() * (i - start + 1));
        [st.remaining[i], st.remaining[j]] = [st.remaining[j], st.remaining[i]];
      }
    }

    function drawReflectionIndex(st){
      st = ensureDecks(st);
      if (!Array.isArray(st.reflectionRemaining) || st.reflectionRemaining.length === 0) return null;
      const idx = st.reflectionRemaining.pop();
      st.reflectionUsed.push(idx);
      return idx;
    }

    // ---- UI ----
    const elCards = document.getElementById("cards");
    const elRemaining = document.getElementById("remaining");
    const elScore = document.getElementById("score");
    const elRound = document.getElementById("round");
    const elStart = document.getElementById("start");
    const elEndRound = document.getElementById("endRound");
    const elReset = document.getElementById("reset");
    const elViewCompleted = document.getElementById("viewCompleted");
    const elViewDeck = document.getElementById("viewDeck");

    // Log modal
    const elBackdropLog = document.getElementById("backdropLog");
    const elCloseLog = document.getElementById("closeLog");
    const elLogList = document.getElementById("logList");
    const elLogEmpty = document.getElementById("logEmpty");
    const elCopyLog = document.getElementById("copyLog");
    const elClearLog = document.getElementById("clearLog");

    // Deck modal
    const elBackdropDeck = document.getElementById("backdropDeck");
    const elCloseDeck = document.getElementById("closeDeck");
    const elDeckContainer = document.getElementById("deckContainer");
    const elCopyDeck = document.getElementById("copyDeck");

    // Reflection modal
    const elBackdropReflection = document.getElementById("backdropReflection");
    const elCloseReflection = document.getElementById("closeReflection");
    const elReflectionTag = document.getElementById("reflectionTag");
    const elReflectionText = document.getElementById("reflectionText");
    const elCopyReflection = document.getElementById("copyReflection");

    function setEndRoundEnabled(st){
      const activeRound = Array.isArray(st.active) && st.active.length >= 1;
      elEndRound.disabled = !(activeRound && !st.reflectionDone && !st.lockedBetweenRounds);
    }

    function render(st){
      st = ensureDecks(st);

      elRemaining.textContent = String((st.remaining || []).length);
      elScore.textContent = String(st.score || 0);
      elRound.textContent = String(st.round || 0);

      setEndRoundEnabled(st);

      elCards.innerHTML = "";

      if (!Array.isArray(st.active) || st.active.length === 0) {
        const div = document.createElement("div");
        div.className = "card";
        div.innerHTML = `
          <div class="tagRow">
            <span class="tag">Ready</span>
          </div>
          <p class="text">Tap <strong>Start Round (Deal 3)</strong> to begin.</p>
          <p class="small">You’ll get three prompts. When you use one, tap <strong>Complete</strong> to replace it.</p>
        `;
        elCards.appendChild(div);
        return;
      }

      if ((st.remaining || []).length === 0) {
        const warn = document.createElement("div");
        warn.className = "card";
        warn.innerHTML = `
          <div class="tagRow">
            <span class="tag">Deck empty</span>
          </div>
          <p class="text">The main deck is out of cards.</p>
          <p class="small">You can keep talking without prompts, or reset the game to reshuffle.</p>
        `;
        elCards.appendChild(warn);
      }

      st.active.forEach((idx, slot) => {
        const c = DECK[idx];
        const div = document.createElement("div");
        div.className = "card";
        if (st.lockedBetweenRounds) div.classList.add("locked");

        div.innerHTML = `
          <div class="tagRow">
            <span class="tag">Card ${slot+1} • ${c.cat}</span>
            <span class="tag">${st.lockedBetweenRounds ? "Between rounds" : "Tap Complete when used"}</span>
          </div>
          <p class="text">${c.text}</p>
          <div class="btnRow">
            <button class="btnSmall btnComplete" data-action="complete" data-slot="${slot}">Complete</button>
            <button class="btnSmall btnRedraw" data-action="redraw" data-slot="${slot}">Redraw</button>
          </div>
          <p class="small">Use it once, then let it go.</p>
        `;

        if (st.lockedBetweenRounds) {
          div.querySelectorAll("button").forEach(b => b.disabled = true);
        }

        elCards.appendChild(div);
      });
    }

    // ---- Log modal ----
    function openLog(st){
      const items = st.completed || [];
      elLogList.innerHTML = "";
      if (items.length === 0) {
        elLogEmpty.style.display = "block";
      } else {
        elLogEmpty.style.display = "none";
        items.slice().reverse().forEach(item => {
          const li = document.createElement("li");
          li.className = "completedItem";

          if (item.type === "reflection") {
            li.classList.add("completedReflection");
            li.textContent = `Round ${item.round} Reflection: ${item.text}`;
          } else {
            li.textContent = `${item.text} (${item.cat})`;
          }

          elLogList.appendChild(li);
        });
      }
      elBackdropLog.style.display = "flex";
    }
    function closeLog(){ elBackdropLog.style.display = "none"; }

    // ---- Deck modal ----
    function groupDeck(){
      const map = new Map();
      for (const c of DECK) {
        if (!map.has(c.cat)) map.set(c.cat, []);
        map.get(c.cat).push(c.text);
      }
      return map;
    }
    function categoryOrder(){
      const seen = new Set();
      const order = [];
      for (const c of DECK) {
        if (!seen.has(c.cat)) { seen.add(c.cat); order.push(c.cat); }
      }
      return order;
    }
    function openDeck(){
      elDeckContainer.innerHTML = "";

      const grouped = groupDeck();
      const order = categoryOrder();

      order.forEach(cat => {
        const title = document.createElement("div");
        title.className = "sectionTitle";
        title.textContent = cat;
        elDeckContainer.appendChild(title);

        const ol = document.createElement("ol");
        ol.className = "deckList";
        grouped.get(cat).forEach(txt => {
          const li = document.createElement("li");
          li.textContent = txt;
          ol.appendChild(li);
        });
        elDeckContainer.appendChild(ol);
      });

      const rTitle = document.createElement("div");
      rTitle.className = "sectionTitle";
      rTitle.textContent = REFLECTION_CATEGORY;
      elDeckContainer.appendChild(rTitle);

      const rOl = document.createElement("ol");
      rOl.className = "deckList";
      REFLECTION_DECK.forEach(r => {
        const li = document.createElement("li");
        li.textContent = r.text;
        rOl.appendChild(li);
      });
      elDeckContainer.appendChild(rOl);

      elBackdropDeck.style.display = "flex";
    }
    function closeDeck(){ elBackdropDeck.style.display = "none"; }

    // ---- Reflection modal ----
    function openReflectionModal(roundNum, reflectionText){
      elReflectionTag.textContent = `Round ${roundNum}`;
      elReflectionText.textContent = reflectionText;
      elBackdropReflection.style.display = "flex";
    }
    function closeReflection(){ elBackdropReflection.style.display = "none"; }

    // ---- Game actions ----
    function startRound(st){
      st = ensureDecks(st);

      // Unlock between rounds
      st.lockedBetweenRounds = false;

      // Initialize main deck only if this is a fresh game
      if ((!st.remaining || st.remaining.length === 0) && (!st.used || st.used.length === 0)) {
        st.remaining = buildMainDeck();
        st.used = [];
      }

      st.active = [];

      // Deal up to 3
      for (let i=0; i<3; i++){
        const idx = drawMainIndex(st);
        if (idx === null) break;
        st.active.push(idx);
      }

      st.round = (st.round || 0) + 1;
      st.reflectionDone = false;

      saveState(st);
      render(st);
    }

    function resetGameConfirmed(){
      localStorage.removeItem(LS_KEY);
      location.reload();
    }

    function redrawOne(st, slot){
      if (st.lockedBetweenRounds) return;

      const oldIdx = st.active[slot];
      returnMainToDeck(st, oldIdx);

      const newIdx = drawMainIndex(st);
      if (newIdx === null) return;

      st.active[slot] = newIdx;
      saveState(st);
      render(st);
    }

    function completeOne(st, slot){
      if (st.lockedBetweenRounds) return;

      const idx = st.active[slot];
      const card = DECK[idx];

      st.score = (st.score || 0) + 1;
      st.completed = st.completed || [];
      st.completed.push({ type:"prompt", cat: card.cat, text: card.text, ts: Date.now() });

      const newIdx = drawMainIndex(st);
      if (newIdx === null) {
        st.active[slot] = null;
        st.active = st.active.filter(x => x !== null);
      } else {
        st.active[slot] = newIdx;
      }

      saveState(st);
      render(st);
    }

    function endConversation(st){
      if (st.reflectionDone || st.lockedBetweenRounds) return;

      const rIdx = drawReflectionIndex(st);
      if (rIdx === null) return;

      const r = REFLECTION_DECK[rIdx];

      st.completed = st.completed || [];
      st.completed.push({
        type: "reflection",
        cat: r.cat,
        text: r.text,
        round: st.round || 0,
        ts: Date.now()
      });

      st.reflectionDone = true;
      st.lockedBetweenRounds = true;

      saveState(st);
      render(st);
      openReflectionModal(st.round || 0, r.text);
    }

    // ---- Init ----
    function init(){
      let st = loadState();
      if (!st) st = structuredClone(DEFAULT_STATE);

      // Initialize decks if never set
      if ((!Array.isArray(st.remaining) || (!st.remaining.length && !(st.used || []).length))) {
        st.remaining = buildMainDeck();
        st.used = [];
      }
      if ((!Array.isArray(st.reflectionRemaining) || (!st.reflectionRemaining.length && !(st.reflectionUsed || []).length))) {
        st.reflectionRemaining = buildReflectionDeck();
        st.reflectionUsed = [];
      }

      st = ensureDecks(st);
      saveState(st);
      render(st);

      // Events
      elStart.addEventListener("click", () => {
        const st2 = loadState() || structuredClone(DEFAULT_STATE);
        startRound(st2);
      });

      elEndRound.addEventListener("click", () => {
        const ok = confirm("End this conversation and draw a reflection prompt for your group?");
        if (!ok) return;

        const st2 = loadState() || structuredClone(DEFAULT_STATE);
        endConversation(st2);
      });

      elReset.addEventListener("click", () => {
        const ok = confirm("Reset the game? This clears score, log, rounds, and reshuffles the deck.");
        if (ok) resetGameConfirmed();
      });

      elCards.addEventListener("click", (e) => {
        const btn = e.target.closest("button");
        if (!btn) return;

        const action = btn.getAttribute("data-action");
        const slot = Number(btn.getAttribute("data-slot"));
        if (!Number.isFinite(slot)) return;

        const st2 = loadState() || structuredClone(DEFAULT_STATE);
        if (!Array.isArray(st2.active) || st2.active.length === 0) return;

        if (action === "redraw") redrawOne(st2, slot);
        if (action === "complete") completeOne(st2, slot);
      });

      elViewCompleted.addEventListener("click", () => {
        const st2 = loadState() || structuredClone(DEFAULT_STATE);
        openLog(st2);
      });

      elCloseLog.addEventListener("click", closeLog);
      elBackdropLog.addEventListener("click", (e) => {
        if (e.target === elBackdropLog) closeLog();
      });

      elViewDeck.addEventListener("click", openDeck);
      elCloseDeck.addEventListener("click", closeDeck);
      elBackdropDeck.addEventListener("click", (e) => {
        if (e.target === elBackdropDeck) closeDeck();
      });

      // Close reflection: prompt to start next round now
      elCloseReflection.addEventListener("click", () => {
        closeReflection();

        const st2 = loadState() || structuredClone(DEFAULT_STATE);
        if (!st2.lockedBetweenRounds) return;

        const next = (st2.round || 0) + 1;
        const ok = confirm(`Start Round ${next} now?`);
        if (!ok) return;

        startRound(st2);
      });

      elBackdropReflection.addEventListener("click", (e) => {
        if (e.target !== elBackdropReflection) return;

        closeReflection();

        const st2 = loadState() || structuredClone(DEFAULT_STATE);
        if (!st2.lockedBetweenRounds) return;

        const next = (st2.round || 0) + 1;
        const ok = confirm(`Start Round ${next} now?`);
        if (!ok) return;

        startRound(st2);
      });

      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape") { closeLog(); closeDeck(); closeReflection(); }
      });

      elCopyLog.addEventListener("click", async () => {
        const st2 = loadState() || structuredClone(DEFAULT_STATE);
        const items = st2.completed || [];
        const lines = items.map((it, i) => {
          if (it.type === "reflection") return `${i+1}. [Round ${it.round} Reflection] ${it.text}`;
          return `${i+1}. ${it.text} (${it.cat})`;
        });
        const text = lines.join("\n");
        try {
          await navigator.clipboard.writeText(text || "");
          elCopyLog.textContent = "Copied!";
          setTimeout(() => elCopyLog.textContent = "Copy log", 900);
        } catch {
          elCopyLog.textContent = "Copy failed";
          setTimeout(() => elCopyLog.textContent = "Copy log", 900);
        }
      });

      elClearLog.addEventListener("click", () => {
        const st2 = loadState() || structuredClone(DEFAULT_STATE);
        st2.completed = [];
        st2.score = 0;
        saveState(st2);
        openLog(st2);
        render(st2);
      });

      elCopyDeck.addEventListener("click", async () => {
        const lines = [];
        const order = categoryOrder();
        for (const cat of order) {
          lines.push(cat);
          const items = DECK.filter(x => x.cat === cat).map(x => `- ${x.text}`);
          lines.push(...items);
          lines.push("");
        }
        lines.push(REFLECTION_CATEGORY);
        lines.push(...REFLECTION_DECK.map(r => `- ${r.text}`));
        const text = lines.join("\n").trim();
        try {
          await navigator.clipboard.writeText(text);
          elCopyDeck.textContent = "Copied!";
          setTimeout(() => elCopyDeck.textContent = "Copy full deck", 900);
        } catch {
          elCopyDeck.textContent = "Copy failed";
          setTimeout(() => elCopyDeck.textContent = "Copy full deck", 900);
        }
      });

      elCopyReflection.addEventListener("click", async () => {
        const txt = elReflectionText.textContent || "";
        try {
          await navigator.clipboard.writeText(txt);
          elCopyReflection.textContent = "Copied!";
          setTimeout(() => elCopyReflection.textContent = "Copy reflection", 900);
        } catch {
          elCopyReflection.textContent = "Copy failed";
          setTimeout(() => elCopyReflection.textContent = "Copy reflection", 900);
        }
      });
    }

    init();
  </script>
</body>
</html>
